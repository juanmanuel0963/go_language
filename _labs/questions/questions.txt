Can you tell us more about Golang and your experience working with this programming language?
---------------------------------------------------------------------------------------------
- Using this question, the hiring manager will try to learn about your understanding of the programming language. 
- You should start with your number of years of experience with Golang. 
- Then, explain the projects you’ve worked on using this programming language.
- Ensure that you describe in detail your role in those projects.

How many years of experience do you have with Golang? What other technologies have you used other than Golang?
--------------------------------------------------------------------------------------------------------------
- You can add the number of years you’ve been practicing the Golang language before using it.
- For example, if you’ve practiced Golang for three years and then started using it in your career for four years, you can say that you have seven years of experience with Golang. 
- As for the other technologies, make sure you list down all the programming languages you’re familiar with and let the hiring manager know about your expertise in those languages. 

What is Golang?
---------------
- Golang, which some professionals refer to as just "Go," is a computer programming language invented by programmers at Google in 2009. 
- It is an open-source language, which means that its code is freely accessible to the general public for modification and sharing. 
- Many individuals, organisations and companies use Golang as their primary coding language due to its open-source nature.

Is Go a new language, framework or library?
-------------------------------------------
- Go isn't a library and not a framework, it's a new language.
- Go is mostly in the C family (basic syntax), with significant input from the Pascal/Modula/Oberon family (declarations, packages).
- Go does have an extensive library, called the runtime, that is part of every Go program.
- Although it is more central to the language, Go's runtime is analogous to libc, the C library.
- It is important to understand, however, that Go's runtime does not include a virtual machine, such as is provided by the Java runtime.
- Go programs are compiled ahead of time to native machine code.

Why should one learn Golang? What are the advantages of Golang over other languages?
------------------------------------------------------------------------------------

- Go language follows the principle of maximum effect with minimum efforts. 
- Every feature and syntax of Go was developed to ease the life of programmers.
- Following are the advantages of Go Language:
  - Simple and Understandable: 
    - Go is very simple to learn and understand.
    - There are no unnecessary features included. 
    - Every single line of the Go code is very easily readable and thereby easily understandable irrespective of the size of the codebase.
    - Go was developed by keeping simplicity, maintainability and readability in mind.
  - Standard Powerful Library:
    - Go supports all standard libraries and packages that help in writing code easily and efficiently.
  - Support for concurrency:
    - Go provides very good support for concurrency using Go Routines or channels. 
    - They take advantage of efficient memory management strategies and multi-core processor architecture for implementing concurrency.
  - Static Type Checking:
    - Go is a very strong and statically typed programming language.
    - Statically typed means every variable has types assigned to it. 
    - The data type cannot be changed once created and strongly typed means that there are rules and restrictions while performing type conversion.
    - This ensures that the code is type-safe and all type conversions are handled efficiently. 
    - This is done for reducing the chances of errors at runtime.
  - Easy to install Binaries: 
    - Go provides support for generating binaries for the applications with all required dependencies.
    - These binaries help to install tools or applications written in Go very easily without the need for a Go compiler or package managers or runtimes.
  - Good Testing Support:
    - Go has good support for writing unit test cases along with our code.
    - There are libraries that support checking code coverage and generating code documentation.

How is GoPATH different from GoROOT variables in Go?
----------------------------------------------------

go env

GOROOT=C:\Program Files\Go
- Where the Go SDK is located.
- The GoROOT determines the location of Go SDK

GOPATH=C:\Users\Juan Manuel\go
- The GoPATH determines the root of the workspace
- The source and the binaries of Go Projects.

How can you configure working environments and parameters? 
----------------------------------------------------------
- You can configure working environments and parameters using JSON, commonly used these days.
- The major advantage of using JSON is that it is available in the standard library. 
- The standard library offers methods to write the data structure intended, which makes it quite readable.
- Another alternative is to use the YAML package for Go. 
  
What are some advantages of using Go?
-------------------------------------
- Go is an attempt to introduce a new, concurrent, garbage-collected language with fast compilation and the following benefits:
- It is possible to compile a large Go program in a few seconds on a single computer.
- Go provides a model for software construction that makes dependency analysis easy and avoids much of the overhead of C-style include files and libraries.
- Go's type system has no hierarchy, so no time is spent defining the relationships between types. 
- Also, although Go has static types, the language attempts to make types feel lighter weight than in typical OO languages.
- Go is fully garbage-collected and provides fundamental support for concurrent execution and communication.
- By its design, Go proposes an approach for the construction of system software on multicore machines.


What are the benefits of using Go programming?
----------------------------------------------
Following are the benefits of using Go programming:
- Support for environment adopting patterns similar to dynamic languages. 
- For example type inference (x := 0 is valid declaration of a variable x of type int).
- Compilation time is fast.
- In built concurrency support: light-weight processes (via goroutines), channels, select statement.
- Conciseness, Simplicity, and Safety.
- Support for Interfaces and Type embedding.
- The go compiler supports static linking. All the go code can be statically linked into one big fat binary and it can be deployed in cloud servers easily without worrying about dependencies.

Is Golang a case-sensitive programming language?
------------------------------------------------
- Yes, Golang is a case-sensitive programming language.
- It is essential to write identifiers like function names, variables and language keywords with consistent capitalisation to produce the desired outputs.
- When you use Golang, capitalisation also determines which packages to export.

How does Golang work so fast?
-----------------------------
- Golang is an incredibly fast performing language due to its design.
- Unlike some other programming languages, it has a small syntax and concurrency model, which helps make it more efficient.
- Golang's compilation system operates quickly and it has the ability to machine code, both of which expedite its pace
- One of the most impactful speed-enhancing features of Golang is its storage arrangement.
- It hyperlinks all the dependency libraries into a single binary file.
- This reduces the language's reliance on servers, and it minimises the data lag you get from this reliance in some other languages.

If you want to grant concurrent data access, is it safer to do so via channels or maps?
---------------------------------------------------------------------------------------
- Granting concurrent data access is much safer via channels than it is with maps.
- Channels feature blocking and locking methods that prevent goroutines from sharing memory in the attendance of several threads.
- Maps do not come with locking methods, so they are not as safe as channels are.
- If you use maps, you need to implement direct locking methods to send data through goroutines without compromising data security.

Can you return multiple values from a function in Golang?
---------------------------------------------------------
- Yes, it is possible to return multiple values from a function in Golang.
- To produce multiple values, you can send multiple values with the return statement and separate them with a comma.
- You can also assign the return statement to multiple variables within a single statement. 
- You may use the reverseValues function to return the values in reverse order or use a more traditional function.

Can you declare different variable types within a single line of code?
----------------------------------------------------------------------
- Yes, it is possible to declare different variable types within a single line of code.
- Computer programmers and other information technology professionals often do this to create their inputs more efficiently.
- For example, you can declare variables like a string, a floating-point integer and an integer number on a single line and return concise outputs with ease.
  var a, b, c =  3,  4,  "foo" 

What is dynamic type declaration of a variable in Go?
-----------------------------------------------------
- A dynamic type variable declaration requires compiler to interpret the type of variable based on value passed to it. 
- Compiler don't need a variable to have type statically as a necessary requirement.

What is static type declaration of a variable in Go?
----------------------------------------------------
- Static type variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable. 
- A variable declaration has its meaning at the time of compilation only, compiler needs actual variable declaration at the time of linking of the program.

What is a pointer?
------------------
- A pointer variable can hold the address of a variable.
- &P: pointer to the variable address
- *P: pointer to the variable value
- In GO a pointer is represented by using the * (asterisk) character followed by the type of the stored value.
- *testing.T

What kind of type conversion is supported by Go?
------------------------------------------------
- Go is very strict about explicit typing. 
- There is no automatic type promotion or conversion. 
- Explicit type conversion is required to assign a variable of one type to another.

i := 55      //int
j := 67.8    //float64
sum := i + int(j) //j is converted to int

Why the Go language was created?
--------------------------------
- Go was born out of frustration with existing languages and environments for systems programming.
- Go is an attempt to have:
  - an interpreted, dynamically typed language with
  - the efficiency and safety of a statically typed, compiled language
  - support for networked and multicore computing
  - be fast in compilation

Can Go have optional parameters? Or can I just define two functions with the same name and a different number of arguments?
---------------------------------------------------------------------------------------------------------------------------
- Go does not have optional parameters nor does it support method overloading:
- Method dispatch is simplified if it doesn't need to do type matching as well. 
- Experience with other languages told us that having a variety of methods with the same name but different signatures was occasionally useful but that it could also be confusing and fragile in practice. 
- Matching only by name and requiring consistency in the types was a major simplifying decision in Go's type system.

Is Go an object-oriented language?
----------------------------------
- Yes and no. 
- Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. 
- This is in contrast to most object-oriented languages like C++, Java, C#, Scala, and even dynamic languages like Python and Ruby.

Go Object-Oriented Language Features
------------------------------------

- Structs - Structs are user-defined types. Struct types (with methods) serve similar purposes to classes in other languages.
- Methods - Methods are functions that operate on particular types. They have a receiver clause that mandates what type they operate on.
- Embedding - we can embed anonymous types inside each other. If we embed a nameless struct then the embedded struct provides its state (and methods) to the embedding struct directly.
- Interfaces - Interfaces are types that declare sets of methods. 
            Similarly to interfaces in other languages, they have no implementation. 
            Objects that implement all the interface methods automatically implement the interface. 
            There is no inheritance or subclassing or "implements" keyword.

The Go way to implement:
------------------------

- Encapsulation - Go encapsulates things at the package level. 
            Names that start with a lowercase letter are only visible within that package. 
            You can hide anything in a private package and just expose specific types, interfaces, and factory functions.
- Inheritance - composition by embedding an anonymous type is equivalent to implementation inheritance.
- Polymorphism - A variable of type interface can hold any value which implements the interface.

How do we perform inheritance with Golang?
------------------------------------------------
- This is a bit of a trick question: there is no inheritance in Golang because it does not support classes.
- However, you can mimic inheritance behavior using composition to use an existing struct object to define a starting behavior of a new object. 
- Once the new object is created, functionality can be extended beyond the original struct.

type Animal struct {
    // …
}

func (a *Animal) Eat()   { … }
func (a *Animal) Sleep() { … }
func (a *Animal) Run() { … }

type Dog struct {
    Animal
    // …
}

- The Animal struct contains Eat(), Sleep(), and Run() functions. 
- These functions are embedded into the child struct Dog by simply listing the struct at the top of the implementation of Dog.

Explain Go interfaces. What are they and how do they work?
----------------------------------------------------------
- Interfaces are a special type in Go that define a set of method signatures but do not provide implementations. 
- Values of interface type can hold any value that implements those methods.
- Interfaces essentially act as placeholders for methods that will have multiple implementations based on what object is using it.
- For example, you could implement a geometry interface that defines that all shapes that use this interface must have an implementation of area() and perim().

type geometry interface {
    area() float64
    perim() float64
}
- An interface is specified as two things.
  A set of methods
  Also it is referred as type

What are Go Interfaces?
-----------------------
- Interfaces in Go are different from other languages. 
- Go Interfaces are a custom type used to specify a set of one or more method signatures.
- The interface is created using the word “type” followed by the name and the keyword interface.
- The interfaces can be defined as:
  A set of methods
  Type

How do you compare two interfaces in Golang?
--------------------------------------------

- You can compare two given interfaces in Golang if:
  The interface value is nil, or
  The underlying type is the same and comparable. The underlying value also has to be the same. 
- You can use == or != operators to compare two interface variable.


Is there a foreach construct in the Go language?
------------------------------------------------

 - A for statement with a range clause iterates through all entries of an array, slice, string or map, or values received on a channel. 
 - For each entry it assigns iteration values to corresponding iteration variables and then executes the block.

What is a Syntax in Golang programming language?
------------------------------------------------

- In Go programming language, a syntax is specified using the Extended Backus-Naur Form (EBNF).

What are the differences between unbuffered and buffered channels?
 ------------------------------------------------------------------
- For unbuffered channel, the sender will block on the channel until the receiver receives the data from the channel, 
  whilst the receiver will also block on the channel until sender sends data into the channel.
- For buffered channel, the sender of buffered channel will block when there is no empty slot of the channel, 
  while the receiver will block on the channel when it is empty.

What is rune type in Go?
------------------------
- There are many other symbols invented by humans other than the 'abcde..' symbols. And there are so many that we need 32 bit to encode them.
- A rune is a builtin type in Go and it's the alias of int32. Rune represents a Unicode CodePoint in Go. 
- It does not matter how many bytes the code point occupies, it can be represented by a rune. For example the rule literal a is in reality the number 97.
- A string is not necessarily a sequence of runes. We can convert between string and []rune, but they are different.

What is so special about constants in Go?
-----------------------------------------
Constants in Go are special.
- Untyped constants. Any constant in golang, named or unnamed, is untyped unless given a type explicitly. 
    For example an untyped floating-point constant like 4.5 can be used anywhere a floating-point value is allowed. 
    We can use untyped constants to temporarily escape from Go’s strong type system until their evaluation in a type-demanding expression.
    // untyped integer constant
    const a = 1
    var myFloat32 float32 = 4.5
    var myComplex64 complex64 = 4.5

- Typed constants. Constants are typed when you explicitly specify the type in the declaration. 
    With typed constants, you lose all the flexibility that comes with untyped constants like assigning them to any variable of compatible type or mixing them in mathematical operations.
    const typedInt int = 1  

- Generally we should declare a type for a constant only if it’s absolutely necessary. 
- Otherwise, just declare constants without a type.

What is the difference between the = and := operator?
-----------------------------------------------------
- In Go, := is for declaration + assignment, 
- whereas = is for assignment only.
- For example, var foo int = 10 is the same as foo := 10.

Why would you prefer to use an empty struct{}?
----------------------------------------------
- You would use an empty struct when you would want to save some memory. 
- Empty structs do not take any memory for its value.

a := struct{}{}
println(unsafe.Sizeof(a))
// Output: 0

- This saving is usually insignificant and is dependent on the size of the slice or a map. 
- Although, more important use of an empty struct is to show a reader you do not need a value at all. 
- Its purpose in most cases is mainly informational.

- The important use of empty struct is to show the developer that we do not have any value. 
- The purpose is purely informational. Some of the examples where the empty struct is useful are as follows:

- While implementing a data set: We can use the empty struct to implement a dataset. Consider an example as shown below.

map_obj := make(map[string]struct{})
for _, value := range []string{"interviewbit", "golang", "questions"} {
   map_obj[value] = struct{}{}
}
fmt.Println(map_obj)

- The output of this code would be:

map[interviewbit:{} golang:{} questions:{}]

- Here, we are initializing the value of a key to an empty struct and initializing the map_obj to an empty struct.

- In graph traversals in the map of tracking visited vertices. 
- For example, consider the below piece of code where we are initializing the value of vertex visited empty struct.

visited := make(map[string]struct{})
for _, isExists := visited[v]; !isExists {
    // First time visiting a vertex.
    visited[v] = struct{}{}
}

- When a channel needs to send a signal of an event without the need for sending any data. 
- From the below piece of code, we can see that we are sending a signal using sending empty struct to the channel which is sent to the workerRoutine.

func workerRoutine(ch chan struct{}) {
    // Receive message from main program.
    <-ch
    println("Signal Received")

    // Send a message to the main program.
    close(ch)
}

func main() {
    //Create channel
    ch := make(chan struct{})
    
    //define workerRoutine
    go workerRoutine(ch)

    // Send signal to worker goroutine
    ch <- struct{}{}

    // Receive a message from the workerRoutine.
    <-ch
    println(“Signal Received")
    
}

- The output of the code would be:

Signal Received
Signal Received
23. How can we 



List the functions that can stop or suspend the execution of current goroutine, and explain their differences.
--------------------------------------------------------------------------------------------------------------

- Four functions can be used to stop or suspend the execution of the current Go Routine:
- runtime.Gosched: This is executed automatically as it gives up the CPU core and joins the queue.
- runtime.gopark: The Go Routine is blocked until the callback function unlock in argument list returnfalse.
- runtime.notesleep: This function will hibernate the thread.
- runtime.Goexit: This will stop the execution of goroutine immediately and call defer, but it will not cause panic.


What are the use(s) for tags in Go?
-----------------------------------
- A tag for a field allows you to attach meta-information to the field which can be acquired using reflection. 
- Usually it is used to provide transformation info on how a struct field is encoded to or decoded from another format (or stored/retrieved from a database), 
  but you can use it to store whatever meta-info you want to, either intended for another package or for your own use.
- The major use of a tag for a field is that it allows you to attach meta information to a field which can be acquired using reflection.
- Tags are usually used to provide transformation info on how a struct field is stored or retrieved from a database. 
- You can also use tags to store whatever meta information you want to add to the field, either for another package or for your own use.
- By convention, the value of a tag string is a space-separated list of key: “value” pairs. 

type User struct {
    Name  string `mytag:"MyName"`
    Email string `mytag:"MyEmail"`
}

u := User{"Bob", "bob@mycompany.com"}
t := reflect.TypeOf(u)

for _, fieldName := range []string{"Name", "Email"} {
    field, found := t.FieldByName(fieldName)
    if !found {
        continue
    }
    fmt.Printf("\nField: User.%s\n", fieldName)
    fmt.Printf("\tWhole tag value : %q\n", field.Tag)
    fmt.Printf("\tValue of 'mytag': %q\n", field.Tag.Get("mytag"))
}

When is the init() function run?
--------------------------------
- init() is called after all the variable declarations in the package have evaluated their initializers, 
  and those are evaluated only after all the imported packages have been initialized.
- If a package has one or more init() functions they are automatically executed before the main package's main() function is called.
- import --> const --> var --> init()
- If a package imports other packages, the imported packages are initialized first.
- Current package's constant initialized then.
- Current package's variables are initialized then.
- Finally, init() function of current package is called.

What data types does Golang use?
--------------------------------

Golang uses the following types:

- Method
- Boolean
- Numeric
- String
- Array
- Slice
- Struct
- Pointer
- Function
- Interface
- Map
- Channel

How do you find the type of an object in Go?
--------------------------------------------
- Golang programming language does not have the concept of a class type;
- thus you don’t have objects in Go.
- Go provides several data types such as int16, int16, int32, int64, float64, string, bool, etc. 
- You can find the type of a variable in Go at runtime using these three different methods:
  Using fmt for a string type description
  Using reflect Package
  Using type assertions

How will you check the type of a variable at runtime in Go?
-----------------------------------------------------------
- In Go, we can use a special type of switch for checking the variable type at runtime.
- This switch statement is called a “type switch”.
- Consider the following piece of code where we are checking for the type of variable v and performing some set of operations.

switch v := param.(type) { 
default:
    fmt.Printf("Unexpected type %T", v)
case uint64:
    fmt.Println("Integer type")
case string:
    fmt.Println("String type")
}

- In the above code, we are checking for the type of variable v, if the type of variable is uint64, then the code prints “Integer type”.
- If the type of variable is a string, the code prints “String type”.
- If the type doesn't match, the default block is executed and it runs the statements in the default block.



What are packages in Golang?
----------------------------

- Packages in Golang, which programmers may refer to as "Go packages," are directories that store Go files. 
- These Go files contain source code, so it is helpful for programmers to use Go packages to maintain records of Go files.
- Programmers store every piece of code, including functions and variables, in Go files.
- Then, they can transform these files into a single linked package.
- Within Golang, every source file resides in a package.
- It is also possible to place multiple packages inside a single larger package for easier organisation.

What are packages in a Go program?
--------------------------------
- Packages (pkg) are directories within your Go workspace that contain Go source files or other packages. 
- Every function, variable, and type from your source files are stored in the linked package. 
- Every Go source file belongs to a package, which is declared at the top of the file using:
  package <packagename>
- You can import and export packages to reuse exported functions or types using:
  import <packagename>
- Golang’s standard package is fmt, which contains formatting and printing functionalities like Println().

What form of type conversion does Go support?
---------------------------------------------

- Go supports explicit type conversion to satisfy its strict typing requirements.
i := 55      //int
j := 67.8    //float64
sum := i + int(j) //j is converted to int

What are function closures?
---------------------------
- Function closures is a function value that references variables from outside its body. 
- The function may access and assign values to the referenced variables.
- For example: adder() returns a closure, which is each bound to its own referenced sum variable.

What is the purpose of a goroutine in Golang?
---------------------------------------------
- An interviewer may ask this question to gauge how well you understand Golang's ability to run multiple functions at once.
- In your response, you can state that a goroutine is a function that runs at the same time as other functions.
- You may also explain that a goroutine helps you attain concurrency when using Golang.
- A goroutine is a function that runs at the same time as other functions.
- It is common to think of a goroutine as a lightweight thread that operates concurrently with other functions and has independent implementation.
- This element helps programmers attain concurrency when they are working with Golang
- The Go runtime system is responsible for managing all goroutines

What are Goroutines?
--------------------
- Goroutines are functions or methods that run concurrently with other functions or methods. 
- Goroutines can be thought of as light weight threads. 
- The cost of creating a Goroutine is tiny when compared to a thread. 
- Its common for Go applications to have thousands of Goroutines running concurrently.
- A goroutine is a function or method that executes concurrently alongside any other goroutines using a special goroutine thread. 
- Goroutine threads are more lightweight than standard threads, with most Golang programs using thousands of goroutines at once.
- To create a goroutine, add the go keyword before the function declaration.
  go f(x, y, z)

Explain what is go routine in GO? How you can stop go routine?
--------------------------------------------------------------

- A goroutine is a function which is capable of running concurrently with other functions.
- To stop goroutine, you pass the goroutine  a signal channel, that signal channel is used to push a value into when you want the goroutine to stop.
- The goroutine polls that channel regularly as soon as it detects a signal, it quits.

  What are Lvalue and Rvalue in Golang?
  -------------------------------------

  Lvalue:
- Refers to a memory location
- Represents a variable identifier
- Mutable
- May appear on the left or right side of the = operator
- For example: In the statement x = 20, x is an lvalue and 20 is an rvalue.

Rvalue:
- Represents a data value stored in memory
- Represents a constant value
- Always appears on the = operator’s right side.

For example, The statement 10 = 20 is invalid because there is an rvalue (10) left of the = operator.

What are the looping constructs in Go?
-------------------------------------

Go has only one looping construct: the for loop.
The for loop has 3 components separated by semicolons:

- The Init statement, which is executed before the loop begins. 
  It’s often a variable declaration only visible within the scope of the for loop.
  i := 0
- The condition expression, which is evaluated as a Boolean before each iteration to determine if the loop should continue.
  i < 10
- The post statement, which is executed at the end of each iteration.
  i++

package main
import "fmt"
func main() {
    sum := 0
    for i := 0; i < 10; i++ {
        sum += i
    } 
    fmt.Println(sum)
}

Explain the difference between concurrency and parallelism in Golang
--------------------------------------------------------------------

- Concurrency is when your program can handle multiple tasks at once 
- while parallelism is when your program can execute multiple tasks at once using multiple processors. 

- In other words, concurrency is a property of a program that allows you to have multiple tasks in progress at the same time, 
  but not necessarily executing at the same time. 
- Parallelism is a runtime property where two or more tasks are executed at the same time.
- Parallelism can therefore be a means to achieve the property of concurrency, but it is just one of many means available to you.

- The key tools for concurrency in Golang are goroutines and channels. 

- Goroutines are concurrent lightweight threads 
- while Channels allow goroutines to communicate with each other during execution.

Explain how you can do testing in GO?
-------------------------------------
- It has a lightweight testing framework consists of the go test command and the testing package. 
- To write a test you have to create a file with a name ending in _testing. 
- Go which contains functions named TestXXX with signature func (t *testing.T). 
- The test framework runs each such function.

List out the built in support in GO?
-------------------------------------

The available built-in-support in GO includes

- Container: container/list , container/heap
- Web Server: net/http
- Cryptography: Crypto/md5 , crypto/sha1
- Compression: compress/ gzip
- Database: database/sql

How can you format the Go source code in an idiomatic way?
----------------------------------------------------------
gofmt -w main.go
gofmt -w -l directory_name/

You have developed a Go program on Linux and want to compile it for both Windows and Mac. Is it possible?
---------------------------------------------------------------------------------------------------------
Yes, it’s possible to compile a Go application for different operating systems.

How can you compile a Go program for Windows and Mac?
----------------------------------------------------------
- Compile the application for Linux
  $Env:GOOS = "linux" 
  go build main.go

- Compile the application for Windows and 64bit CPUs:
  $Env:GOOS = "windows" 
  $Env:GOARCH = "amd64" 
  go build main.go

- Compile the application for Mac and 64bit CPUs:
  $Env:GOOS = "darwin" 
  $Env:GOARCH = "amd64" 
  go build main.go

Starting from an empty file, how would you create a Go program’s basic structure? 
Annotate the most important parts of the source code using comments.
----------------------------------------------------------------------------------

// package clause 
// It starts every Go source file. 
// main is a special name declaring an executable rather than a library (package)
package main

// import declaration.
// It declares packages used in this file.
// fmt is a standard library package uses to print to standard output (console)
import "fmt"

// function declaration. 
// main is a special function name. it’s the entry point for the executable program

func main() {
	// local scoped variables and constants declarations, calling functions etc
	var age int = 20
	var today string = "Monday"

	// Println() function from fmt package prints out a line to stdout
	fmt.Println("Today is", today) // => Today is Monday
	fmt.Println("You age is", age) // => You age is 17

}

What is the string data type in Golang, and how is it represented?
------------------------------------------------------------------

- A string is a series of byte values. 
- It’s a slice of bytes, and any byte slice can be encoded in a string value. 
- So we can encode anything in a string, even beyond just Unicode text, like images or binary applications.

Chat data type
--------------

- Golang doesn’t have a char data type. 
- It uses bytes and runes to represent character values.

Explain BYTE and RUNE types and how they are represented.
------------------------------------------------------------------

- Golang has two integer types called BYTE and RUNE that are aliases for uint8 and int32 data types. 
- The BYTE data type represents ASCII characters, 
- The RUNE data type represents Unicode characters that are encoded in the UTF-8 format by default.
- A RUNE represents a single Unicode character.  For example, RUNE 0x61 in hexadecimal represents the rune literal ‘a.’
- In Golang, we express characters or RUNE literals by enclosing them in single quotes such as ‘a’, ‘b,’, ‘m’, ‘x’ or ‘\n.’

Can you change a specific character in a string?
------------------------------------------------

- No. Strings are immutable (read-only) data types and you cannot change them. 
- If we try to change a specific character in a string, we’ll get a runtime error.

How can you concatenate string values? What happens when concatenating strings?
-------------------------------------------------------------------------------

- To concatenate strings, we can use the addition operator (+). 
- Note that each time we concatenate to a string value, Go creates a new string. 
- That’s because strings are immutable in Go, making this inefficient.

- There is an efficient and recommended way to concatenate string values and that is to use the strings.Builder type, which was introduced in Go 1.10.

Explain ARRAY and SLICE types and the differences between them.
---------------------------------------------------------------

- Golang has two data structures to handle lists of records: ARRAYS and SLICES.

- An ARRAY is a composite, indexable type that stores a collection of elements. 
- An ARRAY has a fixed length. 
- We specify how many items are in the ARRAY when we declare it.
- The ARRAY length is part of its type, so arrays cannot be resized. 

- This is in contrast to a SLICE that has a dynamic length (it can shrink or grow at runtime). 
- Every element in an array or slice must be of the same type.
- Slices are a key data type in Golang and are everywhere.

Give an example of an array and slice declaration.
--------------------------------------------------
- Here’s an example of declaring and initializing an array of type [4] string using the short declaration syntax.
  friends := [4]string{“Dan”, “Diana”, “Paul”, “John”} 

- Here’s an example of declaring and initializing a slice of type [] int using the short declaration syntax.
  numbers := []int{2, 3, 4, 5}

Explain the backing array of a slice value.
-------------------------------------------
- When we create a slice, Go creates a hidden array behind the scenes, called backing or underlying array, and the new slice type variable refers to it.
- The backing array stores the elements, not the slice. 

- Go implements a slice as a data structure called slice header, which is the runtime representation of the slice.
- It contains three fields:
  1- The address of the backing array (a pointer to the first element of the backing array).
  2- The length of the slice. The built-in function len() returns it.
  3- The capacity of the slice which is the size of the backing array after the first element of the slice. It’s returned by the cap() built-in function.

  - Note that a nil slice doesn’t have a backing array, so all the fields in the slice header are equal to zero.

What are the three components of a "slice" in Golang?
-----------------------------------------------------
- A slice in Golang is a type of data structure that varies in sequence length and holds elements of the same type.
- It references an adjacent array segment.
- Its three components are the pointer, length and capacity.
- The pointer refers to the first piece of an array that the slice can access. 
- The length is the figure that sums the total elements within the slice.
- The capacity is by how much the slice is capable of expanding.

What will the following Go program print out?
---------------------------------------------

package main
import "fmt"

func main() {
    n1 := []int{10, 20, 30, 40}
    n1 = append(n1, 100)
    fmt.Println(len(n1), cap(n1))
}

- The program will print out 5 8 
- The append() function creates a new backing array with a larger capacity. 
- This avoids creating a new backing array when the next append() is called.

- Slice capacity = len(array)
- If len(appended) < len(array), capacity = 2 x len(array)
- If len(appended) > len(array), capacity = 2 x (last capacity)

Explain the Golang MAP type and its advantages.
----------------------------------------------
- A map is a collection type like an array or a slice and stores key:value pairs. 
- We can think of a map being like a dict in Python or an Object in JS.
- All the keys and values in a map are statically typed and must have the same type. 
- Keys and values don’t have to be of the exact type, but all keys must be of the same type, and all values in the map must be of the same type. 
- For example, all keys are of type string and all values are of type int.
- We can use any comparable type as a map key.
- A comparable type is that type that supports the comparison operator.
- This is the double equals sign (==).
- The main advantage of maps is that add, get, and delete operations take constant expected time no matter how many entries are in the map. 
- They offer very fast lookups because maps are backed by HashTables. 
- Maps are unordered data structures in Golang.

What is the recommended Golang package for basic operations on files?
---------------------------------------------------------------------

- The OS standard library package provides a platform-independent interface. 
- We use it for system functionality when working with files. 
- The OS interface is intended to be uniform across all operating systems. So the programs we create work the same on Windows, Linux, or Mac.

What other Golang packages are used to work with files?
-------------------------------------------------------
- There are other Go standard library packages, such as io, ioutil, and bufio. They work with files and provide more functionality.

Explain the Object-Oriented Architecture of Golang.
---------------------------------------------------
- Unlike traditional Object-Oriented Programming, Golang does not have a class-object architecture.
- Rather structs and methods hold complex data structures and behavior.
- A struct is nothing more than a schema containing a blueprint of data that a structure will hold.
- Structs are useful to represent concepts from the real world like cars, people, or books.

What is a struct type? Can you change the struct definition at runtime?
-----------------------------------------------------------------------
- A struct is a sequence of named elements called fields. 
- Each field has a name and a type.
- We can also think of a struct as a collection of properties that are related together. 
- They are useful for grouping data together to form records.
- This blueprint is fixed at compile time.
- It’s not allowed to change the name or the type of the fields at runtime.
- We can’t add or remove fields from a struct at runtime.

What are anonymous structs and anonymous struct fields? Give an example of such a struct declaration.
-----------------------------------------------------------------------------------------------------

- An anonymous struct is a struct with no explicitly defined struct type alias.
- Example of a struct with anonymous fields:
type Book struct {
       string
       float64
       bool
   }
bestBook := Book{"1984 by George Orwell", 10.2, false}

 Explain the defer statement in Golang. Give an example of a deferred function’s call.
 -------------------------------------------------------------------------------------
 
 - A defer statement defers or postpones the execution of a function.
 - It postpones the execution until the surrounding function returns, either normally or through a panic call.
 - We use defer to ensure that a function call is performed later in the program’s execution, usually for cleaning resources.
 - For example, let’s say that we want to create a file, write to it, and then close when we’re done with it.
 - Immediately after creating the file variable, we defer the closing of that file.
 - The function that closes the file will be executed at the end of the enclosing function (main) 
   after the operation of writing to the file has finished.

  file, err := os.Open("main.go")
   if err != nil {
       log.Fatal(err)
   }
   defer file.Close()

Explain the pointer type.
--------------------------------

- A variable is a convenient, alphanumeric nickname or label for a memory location.
- A pointer is a variable type that stores the memory address of another variable. 
- A pointer value is the address of a variable, or nil if it hasn’t been initialized yet.
- The pointer points to the memory address of a variable, just as a variable represents the memory address of a value.

- For example, if variable bb has value 156 and is stored at memory address 0x1040a124 then the variable aa (pointer) holds the address of bb (0x1040a124).
- Now aa is set to point to bb or aa is a pointer to bb. 

Write a Golang program that declares a string variable, prints the address of the variable, declares another int variable, and a pointer to it.
-----------------------------------------------------------------------------------------------------------------------------------------------

package main

import "fmt"

func main() {

	//Go provides the & (ampersand) operator also known as the address of operator.
	lang := "Golang"
	fmt.Println(&lang) // -> 0xc00010a040

	var x int = 2                                                                  // -> int value
	ptr := &x                                                                      // -> pointer to int
	fmt.Printf("ptr is of type %T with value %v and address %p\n", ptr, ptr, &ptr) // -> the pointer is saved at an address as well

What are the advantages of passing pointers to functions?
---------------------------------------------------------

- Golang is a pass by value language. 
- If we pass a non-pointer variable type to a function, the function will create a copy of the variable.
- Any change to the variable, so to the function’s argument, will not be seen to the outside world.
- Pointers have the power to mutate or change the data they are pointing to.
- So if we pass a pointer to a function, and inside the function we change the value the pointer is pointing to, 
  then the change will be seen outside the function. 
- In a nutshell, we pass pointers to functions when we want to change the values of the variables inside the function’s body.

What are Golang methods? 
------------------------
- Golang doesn’t have classes, but we can define methods on defined types. 
- A type may have a method set associated with it which enhances the type with extra behavior.
- This way a named type has both data and behavior, and represents better a real-world concept.
- Methods are also known as receiver functions.

Create a Go program that defines a named type and a method (receiver function) for that type.
------------------------------------------------------------------------------------------------

import (
	"fmt"
)
 
// declaring a new type
type names []string
 
// declaring a method (function receiver)
func (n names) print() {
	// n is called method's receiver
	// n is the actual copy of the names we're working with and is available in the function.
	// n is like this or self from OOP.
	// any variable of type names can call this function on itself like variable_name.print()
 
	// iterating and printing all names
	for i, name := range n {
		fmt.Println(i, name)
	}
}
 
func main() {
 
	// declaring a value of type names
	friends := names{"Dan", "Marry"}
	// calling the print() method on friends variable
	friends.print()
 
	// another way to call a method on a named type
	names.print(friends)
}

What is a goroutine? Go deeper into it.
---------------------------------------

- A goroutine is a function that is capable of running concurrently with other functions.
- It’s a lightweight thread of execution.
- When a Go program is running, the main goroutine is created and launched.
- Other goroutines are created using the go keyword.
- So any function that is called using the go keyword before its name becomes a goroutine.
- The difference between OS threads and goroutines is that OS threads are scheduled by the OS kernel.
- And this is a slow operation due to the amount of memory access required.
- The Go runtime contains its scheduler to schedule goroutines.
- A goroutine is very cheap. 
- It’s practical to have thousands, even hundreds of thousands, of goroutines.  

Explain why concurrency is not parallelism?
---------------------------------------

- Concurrency means loading more goroutines at a time.
- These goroutines are multiple threads of execution.
- If one goroutine blocks, another one is picked up and started.
- On a single-core CPU, we can run only concurrent applications, but they are not run in parallel. They run sequentially
- On the other hand, parallelism means multiple goroutines are executed at the same time. It requires multiple CPUs.
- Concurrency and parallelism are related but distinct concepts.
- Concurrency means independently executing processes or dealing with multiple things at once,
- While parallelism is the simultaneous execution of processes and requires multiple core CPUs.


What is a data race?
--------------------

- Executing many goroutines at the same time without special handling can introduce an error called “Race Condition” or “Data Race.” 
- A Data Race occurs when two goroutines are accessing memory at the same time, one of which is writing.
- Race conditions occur because of unsynchronized access to shared memory. 
- They are among the most common and hardest to debug types of bugs in concurrent systems. 

How could you detect a data race in Go code?
--------------------------------------------

- Starting with Go 1.1, a new tool called race detector for finding race conditions in Go code was made available.  
- Using the race detector is simple. We just add a -race flag to our normal Go command-line tool.
- When the -race command-line flag is set, the compiler inspects all memory accesses with code that records when and how the memory was accessed.
- In the meantime,  the runtime library watches for unsynchronized access to shared variables. 
- Example of running a Go program with the race detector: go run -race main.go

// go run -race command_with_args.go twitter facebook whatsapp
// go test -race

What is Go Channel? What operations are available on the channel type?
----------------------------------------------------------------------

- A channel in Go provides a connection between two goroutines, allowing them to communicate. (???)
- The data we are sending through or receiving from a channel must always be of the same type. 
- This is the type specified when we’ve created the channel.

What operations are available on the channel type?
--------------------------------------------------

- A channel is a 2-way messaging object that has two principal operations: send and receive.
- A send statement transmits a value from one goroutine to another goroutine.
- It executes a corresponding receive expression. 
- The transmission goes through the channel.
- Both operations are written using the channel operator(<-).
- Channels are used to communicate in between running goroutines.

Write a simple Golang program that uses a goroutine and a channel.
------------------------------------------------------------------

package channels

func SendReceive(n int, ch chan int) {

	//sending into the channel
	ch <- n * 2
}

package channels

import (
	"fmt"
	"testing"
)

func TestSendReceive(t *testing.T) {

	// declaring a bidirectional channel that transports data of type int
	c := make(chan int)
	fmt.Printf("%T\n", c)

	// starting the goroutine
	go SendReceive(10, c)

	//receiving data from the channel
	n := <-c
	fmt.Println("Value received:", n)

	fmt.Println("Exiting main ...")

}


How GC works in Go programming language?
----------------------------------------

- There are many garbage collection methods. 
- Go has a Mark-and-Sweep garbage collector. It works in two phases:
- Mark: 
  Start with Stop-the-world and set a write barrier to know how much was allocated during the mark phase.
  Mark all the memory that is still being used by the app. After that, remove the write barrier. 
- Sweep:
  The second phase is Sweep which happens after new allocations.

What is an idiomatic way of representing enums in Go?
-----------------------------------------------------
- Golang programming language does not support enums directly.
- You can implement enums using iota and constants.
- You can implement an enumerated type using the following methods:
  By creating a new integer type
  By listing its value using iota
  By giving the type a String function

How can you compare two structures? Give an example.
-----------------------------------------------------

- You can use the == operator to compare two structures. 
- Ensure that they don’t contain slices, maps, or functions. Otherwise, the code won’t comply.

What is the idiomatic Go equivalent of C’s ternary operator? Explain with an example.
-------------------------------------------------------------------------------------
- There is no direct equivalent of C’s ternary operator in Go. 
- You can use an if-else block instead
- For example:

package if_else

import (
	"fmt"
	"testing"
)

func TestIfElse(t *testing.T) {

	var x, y, result int

	x = 5
	y = 10

	if x > y {
		result = x
	} else {
		result = y
	}

	fmt.Println(result)

}

How can you check if two slices are equal in Golang?
----------------------------------------------------
- You need to loop over each of the elements in the slice and test.
- Equality for slices is not defined.
- However, there is a bytes. 
- Equal function if you are comparing values of type []byte.

package slices

func SliceCompare(A_slice []int, B_slice []int) bool {

	if len(A_slice) != len(B_slice) {

		return false

	}

	for i := range A_slice {

		if A_slice[i] != B_slice[i] {

			return false

		}

	}

	return true
}

Does Go have exceptions?
------------------------

- No, Go takes a different approach. 
- For plain error handling, Go's multi-value returns make it easy to report an error without overloading the return value.
- Go code uses error values to indicate an abnormal state.

func Open(name string) (file *File, err error)
{
    f, err := os.Open("filename.ext")
    if err != nil {
        log.Fatal(err)
    }
    // do something with the open *File f
}

Let's talk variable declaration in Go. Could you explain what is a variable "zero value"?
-----------------------------------------------------------------------------------------
- Variable is the name given to a memory location to store a value of a specific type. There are various syntaxes to declare variables in go.
- If a variable is not assigned any value, go automatically initialises it with the zero value of the variable's type. 
- Go is strongly typed, so variables declared as belonging to one type cannot be assigned a value of another type.

// 1 - variable declaration, then assignment
var age int
age = 29

// 2 - variable declaration with initial value
var age2 int = 29


// 3 - Type inference
var age3 = 29


// 4 - declaring multiple variables
var width, height int = 100, 50


// 5 - declare variables belonging to different types in a single statement
var (
name1 = initialvalue1,
name2 = initialvalue2
)
// 6 - short hand declaration
name, age4 := "naveen", 29 //short hand declaration


What do you understand by Golang string literals?
-------------------------------------------------

- String literals are those variables storing string constants that can be a single character or that can be obtained as a result of the concatenation of a sequence of characters.
- Go provides two types of string literals. They are:
  - Raw string literals:
    - Here, the values are uninterrupted character sequences between backquotes. 
      - For example `uninterrupted \n string`
  - Interpreted string literals:
    - Here, the character sequences are enclosed in double quotes. The value may or may not have new lines. 
      - For example: "interrupted \n string"

What do you understand by the scope of variables in Go?
-------------------------------------------------------

- The variable scope is defined as the part of the program where the variable can be accessed.
- Every variable is statically scoped (meaning a variable scope can be identified at compile time) in Go which means that the scope is declared at the time of compilation itself.
- There are two scopes in Go, they are:
  - Local variables:
    - These are declared inside a function or a block and is accessible only within these entities.
  - Global variables:
    - These are declared outside function or block and is accessible by the whole source file.

How can we check if the Go map contains a key?
----------------------------------------------

- A map, in general, is a collection of elements grouped in key-value pairs.
- One key refers to one value.
- Maps provide faster access in terms of O(1) complexity to the values if the key is known.
- Once the values are stored in key-value pairs in the map, we can retrieve the object by using the key as map_name[key_name]
- and we can check if the key, say “foo”, is present or not and then perform some operations by using the below code:

if val, isExists := map_obj["foo"]; isExists {
    //do steps needed here
}

- From the above code, we can see that two variables are being initialized. 
- The val variable would get the value corresponding to the key “foo” from the map.
- If no value is present, we get “zero value” and the other variable isExists will get a bool value that will be set to true if the key “foo” is present in the map else false.
- Then the isExists condition is evaluated, if the value is true, then the body of the if would be executed.


What do you understand by each of the functions demo_func() as shown in the below code?
---------------------------------------------------------------------------------------

//DemoStruct definition
type DemoStruct struct {
    Val int
}
//A.
func demo_func() DemoStruct {
    return DemoStruct{Val: 1}
}
//B.
func demo_func() *DemoStruct {
    return &DemoStruct{}
}
//C.
func demo_func(s *DemoStruct) {
    s.Val = 1
}

- A. Since the function has a return type of the struct, the function returns a copy of the struct by setting the value as 1.
- B. Since the function returns *DemoStruct, which is a pointer to the struct, it returns a pointer to the struct value created within the function.
- C. Since the function expects the existing struct object as a parameter and in the function, we are setting the value of its attribute, at the end of execution the value of Val variable of the struct object is set to 1.

Can you format a string without printing?
-----------------------------------------

- Yes, we can do that by using the Sprintf command as shown in the example below:

return fmt.Sprintf ("Size: %d MB.", 50)

- The fmt.Sprintf function formats a string and returns the string without printing it

What do you understand by Type Assertion in Go?
-----------------------------------------------

- The type assertion takes the interface value and retrieves the value of the specified explicit data type. The syntax of Type Assertion is:

t := i.(type)

- Here, the statement asserts that the interface value i has the concrete type T and assigns the value of type T to the variable t. 
- In case i does not have concrete type T, then the statement will result in panic.

- For testing, if an interface has the concrete type, we can do it by making use of two values returned by type assertion.
- One value is the underlying value and the other is a bool value that tells if the assertion is completed or not. The syntax would be:

t, isSuccess := i.(type)

- Here, if the interface value i have T¿type, then the underlying value will be assigned to t and the value of isSuccess becomes true.
- Else, the isSuccess statement would be false and the value of t would have the zero value corresponding to type type.
- This ensures there is no panic if the assertion fails.

Is the usage of Global Variables in programs implementing goroutines recommended?
---------------------------------------------------------------------------------

- Using global variables in goroutines is not recommended because it can be accessed and modified by multiple goroutines concurrently. 
- This can lead to unexpected and arbitrary results.


In Go, are there any good error handling practices?
---------------------------------------------------

- In Go, the errors are nothing but an interface type where any type implementing the single Error() method is considered as an error.
- Go does not have try/catch methods as in other programming languages for handling the errors.
- They are instead returned as normal values. Following is the syntax for creating the error interface:

type error_name interface {
    Error() string
}

- We use this whenever we apprehend that there are possibilities where a function can go wrong during type conversions or network calls. 
- The function should return an error as its return variable if things go wrong. 
- The caller has to check this error value and identify the error.
- Any value other than nil is termed as an error.
- As part of good error handling practices, guard classes should be used over if-else statements. 
- They should also be wrapped in a meaningful way as they can be passed up in the call stack.
- Errors of the same types should not be logged or handled multiple times.

How can you sort a slice of custom structs with the help of an example?
-----------------------------------------------------------------------

- We can sort slices of custom structs by using sort.Sort and sort.Stable functions.
- These methods sort any collection that implements sort.Interface interface that has Len(), Less() and Swap() methods as shown in the code below:

type Interface interface {
        // Find number of elements in collection
        Len() int
        
        // Less method is used for identifying which elements among index i and j are lesser and is used for sorting
        Less(i, j int) bool
        
        // Swap method is used for swapping elements with indexes i and j
        Swap(i, j int)
}

- Consider an example of a Human Struct having name and age attributes.

type Human struct {
    name string
    age  int
}


- Also, consider we have a slice of struct Human of type AgeFactor that needs to be sorted based on age.
- The AgeFactor implements the methods of the sort.Interface. 
- Then we can call sort.Sort() method on the audience as shown in the below code:

// AgeFactor implements sort.Interface that sorts the slice based on age field.
type AgeFactor []Human
func (a AgeFactor) Len() int           { return len(a) }
func (a AgeFactor) Less(i, j int) bool { return a[i].age < a[j].age }
func (a AgeFactor) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }

func main() {
    audience := []Human{
        {"Alice", 35},
        {"Bob", 45},
        {"James", 25},
    }
    sort.Sort(AgeFactor(audience))
    fmt.Println(audience) 
}

- This code would output:

[{James 25} {Alice 35} {Bob 45}]

What do you understand by Shadowing in Go?
------------------------------------------

- Shadowing is a principle when a variable overrides a variable in a more specific scope.
- This means that when a variable is declared in an inner scope having the same data type and name in the outer scope, the variable is said to be shadowed.
- The outer variable is declared before the shadowed variable.

- Consider a code snippet as shown below:

var numOfCars = 2    // Line 1
type Car struct{
	name string
	model string
	color string
}
cars:= [{
            name:"Toyota",
            model:"Corolla",
            color:"red"
        },
        {
	    name:"Toyota",
            model:"Innova",
            color:"gray"
	}]

func countRedCars(){
    for i:=0; i<numOfCars; i++{
	if cars[i].color == "red" {
		numOfCars +=1    // Line 2
		fmt.Println("Inside countRedCars method ", numOfCars)    //Line 3
	}
    }	    
}

- Here, we have a function called countRedCars where we will be counting the red cars. 
- We have the numOfCars variable defined at the beginning indicated by the Line 1 comment.
- Inside the countRedCars method, we have an if statement that checks whether the colour is red and if red then increments the numOfCars by 1.
- The interesting point here is that the value of the numCars variable after the end of the if statement will not be affecting the value of the numOfCars variable in the outer scope.


What do you understand by variadic functions in Go?
---------------------------------------------------

- The function that takes a variable number of arguments is called a variadic function. 
- We can pass zero or more parameters in the variadic function. 
- The best example of a variadic function is fmt.Printf which requires one fixed argument as the first parameter and it can accept any arguments.
  - The syntax for the variadic function isHere, we see that the type of the last parameter is preceded by the ellipsis symbol (...) which indicates that the function can take any number of parameters if the type is specified.
  - Inside the variadic function, the ... type can be visualised as a slice. 
    We can also pass the existing slice (or multiple slices) of the mentioned type to the function as a second parameter. 
    When no values are passed in variadic function, the slice is treated as nil.
  - These functions are generally used for string formatting.
  - Variadic parameter can not be specified as return value, but we can return the variable of type slice from the function.

- Consider an example code below:

func function_name(arg1, arg2...type)type{
    // Some statements
}

package main
 
import(
    "fmt"
    "strings"
)
 
// Variadic function to join strings and separate them with hyphen
func joinstring(element...string)string{
    return strings.Join(element, "-")
}
 
func main() {
   
  // To demonstrate zero argument
   fmt.Println(joinstring())
    
   // To demonstrate multiple arguments
   fmt.Println(joinstring("Interview", "Bit"))
   fmt.Println(joinstring("Golang", "Interview", "Questions"))
    
}

- Here, we have a variadic function called joinstring that takes a variable number of arguments of a type string. 
- We are trying to join the arguments separated by the hyphen symbol.
- We are demonstrating the variadic function behaviour by first passing 0 arguments and then passing multiple arguments to the function.
- The output of this code is:

Interview-Bit
Golang-Interview-Questions

